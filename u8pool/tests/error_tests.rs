use u8pool::{U8Pool, U8PoolError};

#[test]
fn test_error_zero_max_slices() {
    let mut buffer = [0u8; 600];
    let result = U8Pool::new(&mut buffer, 0);
    assert_eq!(
        result.unwrap_err(),
        U8PoolError::InvalidConfiguration {
            parameter: "max_slices",
            value: 0
        }
    );
}

#[test]
fn test_error_zero_size_buffer() {
    let mut buffer = [];
    let result = U8Pool::new(&mut buffer, 1);
    assert_eq!(result.unwrap_err(), U8PoolError::ZeroSizeBuffer);
}

#[test]
fn test_error_buffer_too_small_for_metadata() {
    let mut buffer = [0u8; 3]; // Too small for even 1 slice (4 bytes needed + 1 for data)
    let result = U8Pool::new(&mut buffer, 1);
    assert_eq!(
        result.unwrap_err(),
        U8PoolError::BufferTooSmall {
            required: 5, // 4 bytes metadata + 1 byte data minimum
            provided: 3
        }
    );
}

#[test]
fn test_error_detailed_buffer_overflow() {
    let mut buffer = [0u8; 140]; // 32*4=128 bytes metadata + 12 bytes data
    let mut u8pool = U8Pool::with_default_max_slices(&mut buffer).unwrap();

    // Fill buffer to near capacity
    u8pool.push(b"small").unwrap();

    // Try to add data that won't fit
    let large_data = vec![b'x'; 10]; // This should exceed remaining space
    let result = u8pool.push(&large_data);
    match result.unwrap_err() {
        U8PoolError::BufferOverflow {
            requested,
            available,
        } => {
            assert_eq!(requested, 10);
            assert!(available < 10);
        }
        _ => panic!("Expected BufferOverflow error"),
    }
}

#[test]
fn test_error_detailed_index_out_of_bounds() {
    let mut buffer = [0u8; 600];
    let mut u8pool = U8Pool::with_default_max_slices(&mut buffer).unwrap();

    u8pool.push(b"test").unwrap();

    let result = u8pool.get(5);
    assert!(result.is_none());
}

#[test]
fn test_error_slice_limit_exceeded() {
    let mut buffer = [0u8; 600];
    let mut u8pool = U8Pool::new(&mut buffer, 2).unwrap(); // Only 2 slices allowed

    u8pool.push(b"first").unwrap();
    u8pool.push(b"second").unwrap();

    let result = u8pool.push(b"third");
    assert_eq!(
        result.unwrap_err(),
        U8PoolError::SliceLimitExceeded { max_slices: 2 }
    );
}

#[test]
fn test_error_empty_vector_operations() {
    let mut buffer = [0u8; 600];
    let mut u8pool = U8Pool::with_default_max_slices(&mut buffer).unwrap();

    // Test pop on empty vector returns None
    assert_eq!(u8pool.pop(), None);

}

#[test]
fn test_error_messages_quality() {
    let mut buffer = [0u8; 3];
    let error = U8Pool::new(&mut buffer, 1).unwrap_err();
    let message = format!("{:?}", error);
    assert!(message.contains("BufferTooSmall"));
    assert!(message.contains("5"));
    assert!(message.contains("3"));

    // IndexOutOfBounds errors are no longer generated by get() 
    // since it now returns Option<&[u8]> instead of Result
}

#[test]
fn test_error_types_implement_standard_traits() {
    let error = U8PoolError::EmptyVector;

    // Test Debug
    let debug_str = format!("{:?}", error);
    assert!(!debug_str.is_empty());

    // Test Debug (instead of Display since we removed Display impl)
    let debug_str2 = format!("{:?}", error);
    assert!(!debug_str2.is_empty());

    // Test Clone
    let cloned = error.clone();
    assert_eq!(error, cloned);

    // Test PartialEq
    assert_eq!(error, U8PoolError::EmptyVector);
    assert_ne!(error, U8PoolError::ZeroSizeBuffer);

    // Note: Error trait not available in no_std
}

#[test]
fn test_comprehensive_error_scenarios() {
    // Test all error variants have proper error messages
    let errors = [
        U8PoolError::BufferOverflow {
            requested: 100,
            available: 50,
        },
        U8PoolError::IndexOutOfBounds {
            index: 5,
            length: 2,
        },
        U8PoolError::EmptyVector,
        U8PoolError::BufferTooSmall {
            required: 100,
            provided: 50,
        },
        U8PoolError::SliceLimitExceeded { max_slices: 8 },
        U8PoolError::ZeroSizeBuffer,
        U8PoolError::InvalidConfiguration {
            parameter: "test",
            value: 0,
        },
    ];

    for error in &errors {
        let message = format!("{:?}", error);
        assert!(
            !message.is_empty(),
            "Error message should not be empty for {:?}",
            error
        );
        assert!(
            message.len() > 10,
            "Error message should be descriptive for {:?}",
            error
        );
    }
}
