# U8Pool - LLM Documentation

This document provides comprehensive information about U8Pool for Large Language Models to understand and use the library effectively.

## Core Concept

U8Pool is a zero-allocation vector implementation that stores all data in a client-provided buffer. It provides three interfaces to the same underlying data:

1. **Vector Interface**: Standard indexed access (`push`, `get`, `len`, etc.)
2. **Stack Interface**: LIFO operations (`push`, `pop`, `top`)  
3. **Dictionary Interface**: Key-value semantics where even indices are keys, odd indices are values

## Buffer Layout and Memory Management

### Memory Layout
```
Buffer: [metadata_section][data_section]
Metadata: slice_descriptor_0, slice_descriptor_1, ...
Descriptor: (start_offset: usize, length: usize) // 16 bytes total
```

### Buffer Size Calculation
```rust
buffer_size = (max_slices * 16) + estimated_data_size
```

Example:
```rust
// For 50 slices with average 30 bytes per slice
let buffer_size = (50 * 16) + (50 * 30); // 2300 bytes
let mut buffer = vec![0u8; buffer_size];
let mut u8pool = U8Pool::new(&mut buffer, 50)?;
```

## API Reference

### Construction
```rust
// Default: 8 max slices
U8Pool::with_default_max_slices(&mut buffer) -> Result<U8Pool, U8PoolError>

// Custom max slices
U8Pool::new(&mut buffer, max_slices: usize) -> Result<U8Pool, U8PoolError>
```

### Vector Interface
```rust
// Adding elements
push(&mut self, data: &[u8]) -> Result<(), U8PoolError>

// Accessing elements  
get(&self, index: usize) -> &[u8]                    // Panics on bounds
try_get(&self, index: usize) -> Result<&[u8], U8PoolError>  // Safe variant
len(&self) -> usize
is_empty(&self) -> bool
clear(&mut self)

// Iteration
iter(&self) -> U8PoolIter                            // Returns iterator
// Also implements IntoIterator for for-loop syntax
```

### Stack Interface
```rust
// Adding/removing
push(&mut self, data: &[u8]) -> Result<(), U8PoolError>  // Primary method
pop(&mut self) -> Option<&[u8]>                          // Returns None if empty
try_pop(&mut self) -> Result<&[u8], U8PoolError>         // Safe variant

// Inspection
top(&self) -> &[u8]                                     // Panics if empty  
try_top(&self) -> Result<&[u8], U8PoolError>           // Safe variant
```

### Dictionary Interface
```rust
// Smart adding (replaces if same type, adds if different)
add_key(&mut self, data: &[u8]) -> Result<(), U8PoolError>
add_value(&mut self, data: &[u8]) -> Result<(), U8PoolError>

// Dictionary properties
is_key(&self, index: usize) -> bool                    // True if index % 2 == 0
is_value(&self, index: usize) -> bool                  // True if index % 2 == 1
has_unpaired_key(&self) -> bool                        // True if len() % 2 == 1
pairs_count(&self) -> usize                            // Number of complete pairs

// Iteration
pairs(&self) -> U8PoolPairIter                         // Yields (key, Option<value>)
```

## Error Handling

U8Pool uses the `thiserror` crate for comprehensive error handling while maintaining `no_std` compatibility. All errors implement both structured data access and descriptive Display messages.

### Error Types
```rust
use thiserror::Error;

#[derive(Error, Debug, PartialEq, Eq, Clone)]
pub enum U8PoolError {
    #[error("Buffer overflow: requested {requested} bytes, but only {available} bytes available")]
    BufferOverflow { requested: usize, available: usize },
    
    #[error("Index out of bounds: index {index} is beyond vector length {length}")]
    IndexOutOfBounds { index: usize, length: usize },
    
    #[error("Slice limit exceeded: maximum {max_slices} slices allowed")]
    SliceLimitExceeded { max_slices: usize },
    
    #[error("Zero-size buffer provided where data storage is required")]
    ZeroSizeBuffer,
    
    #[error("Invalid configuration: parameter '{parameter}' has invalid value {value}")]
    InvalidConfiguration { parameter: &'static str, value: usize },
}
```

### Key Error Handling Features
- **Descriptive messages**: Each error variant includes a human-readable message via `#[error("...")]`
- **Structured data**: Error variants include specific fields for programmatic handling
- **`no_std` compatibility**: Uses `thiserror` with `default-features = false`
- **Standard traits**: Implements `Error`, `Debug`, `PartialEq`, `Eq`, and `Clone`

### Error Handling Patterns
```rust
// Pattern 1: Match specific errors with descriptive messages
match u8pool.push(large_data) {
    Ok(_) => {},
    Err(U8PoolError::BufferOverflow { requested, available }) => {
        println!("Error: {}", U8PoolError::BufferOverflow { requested, available }); // "Buffer overflow: requested 200 bytes, but only 84 bytes available"
        println!("Details: need {} bytes, have {}", requested, available);
    },
    Err(e) => println!("Other error: {}", e),
}

// Pattern 2: Use ? operator for error propagation
fn process_data(u8pool: &mut U8Pool, data: &[u8]) -> Result<(), U8PoolError> {
    u8pool.push(data)?; // Automatically propagates U8PoolError with descriptive message
    Ok(())
}

// Pattern 3: Use safe get to avoid panics
if let Some(data) = u8pool.get(index) {
    // Process data safely
} else {
    println!("Invalid index: {}", index);
}

// Pattern 4: Error logging with context
match u8pool.add_key(key_data) {
    Ok(_) => {},
    Err(U8PoolError::SliceLimitExceeded { max_slices }) => {
        log::error!("Cannot add key: {}", U8PoolError::SliceLimitExceeded { max_slices }); // Full descriptive message
        log::debug!("Max slices configured: {}", max_slices); // Structured data
    },
    Err(e) => log::error!("Unexpected error adding key: {}", e),
}

// Pattern 5: Error recovery with detailed context
fn robust_add(u8pool: &mut U8Pool, data: &[u8]) -> Result<bool, U8PoolError> {
    match u8pool.push(data) {
        Ok(_) => Ok(true),
        Err(U8PoolError::BufferOverflow { available, .. }) if available > data.len() / 2 => {
            // Try adding half the data if there's some space
            u8pool.push(&data[..available / 2])?;
            Ok(false) // Partial success
        },
        Err(e) => {
            log::warn!("Failed to add data: {}", e); // Descriptive error message
            Err(e)
        }
    }
}
```

## Usage Patterns

### Pattern 1: Vector Operations
```rust
let mut buffer = [0u8; 1000];
let mut u8pool = U8Pool::with_default_max_slices(&mut buffer)?;

// Add elements
u8pool.push(b"first")?;
u8pool.push(b"second")?;
u8pool.push(b"third")?;

// Access by index
for i in 0..u8pool.len() {
    println!("Element {}: {:?}", i, u8pool.get(i).unwrap());
}

// Iterate
for (i, slice) in u8pool.iter().enumerate() {
    println!("Element {}: {:?}", i, slice);
}
```

### Pattern 2: Stack Operations
```rust
let mut buffer = [0u8; 500];
let mut u8pool = U8Pool::with_default_max_slices(&mut buffer)?;

// Build stack
u8pool.push(b"bottom")?;
u8pool.push(b"middle")?;
u8pool.push(b"top")?;

// Process stack
while let Some(item) = u8pool.pop() {
    println!("Processing: {:?}", item);
}
```

### Pattern 3: Dictionary Operations
```rust
let mut buffer = [0u8; 800];
let mut u8pool = U8Pool::new(&mut buffer, 20)?;

// Build dictionary
u8pool.add_key(b"name")?;
u8pool.add_value(b"Alice")?;
u8pool.add_key(b"age")?;
u8pool.add_value(b"30")?;

// Iterate pairs
for (key, value) in u8pool.pairs() {
    match value {
        Some(val) => println!("{:?} = {:?}", key, val),
        None => println!("{:?} = <no value>", key),
    }
}

// Check for unpaired keys
if u8pool.has_unpaired_key() {
    println!("Warning: incomplete key-value pair");
}
```

### Pattern 4: Smart Dictionary Building
```rust
let mut buffer = [0u8; 600];
let mut u8pool = U8Pool::with_default_max_slices(&mut buffer)?;

// Smart replacement logic
u8pool.add_key(b"name")?;         // Adds key
u8pool.add_key(b"username")?;     // Replaces previous key
u8pool.add_value(b"alice")?;      // Adds value
u8pool.add_value(b"bob")?;        // Replaces previous value

// Result: [username, bob]
assert_eq!(u8pool.len(), 2);
assert_eq!(u8pool.get(0).unwrap(), b"username");
assert_eq!(u8pool.get(1).unwrap(), b"bob");
```

### Pattern 5: Mixed Interface Usage
```rust
let mut buffer = [0u8; 1500];
let mut u8pool = U8Pool::new(&mut buffer, 30)?;

// Configuration parsing workflow
u8pool.add_key(b"host")?;         // Dictionary for config
u8pool.add_value(b"localhost")?;
u8pool.add_key(b"port")?;
u8pool.add_value(b"8080")?;

u8pool.push(b"tag1")?;             // Vector for tags
u8pool.push(b"tag2")?;

u8pool.push(b"temp_state")?;      // Stack for processing state

// Process using appropriate interface
let config_pairs = u8pool.pairs().take(2).collect::<Vec<_>>();
let temp_state = u8pool.pop(); // Returns Option<&[u8]>
let tag_count = u8pool.len() - 4; // Remaining elements after config pairs
```

## Dictionary Convention Details

### Key-Value Mapping
- Index 0, 2, 4, ... → Keys
- Index 1, 3, 5, ... → Values  
- Pair (i): key at index 2*i, value at index 2*i+1

### Unpaired Key Handling
```rust
u8pool.push(b"key1")?;     // Index 0 (key)
u8pool.push(b"value1")?;   // Index 1 (value) 
u8pool.push(b"key2")?;     // Index 2 (key) - unpaired!

assert_eq!(u8pool.len(), 3);
assert!(u8pool.has_unpaired_key());
assert_eq!(u8pool.pairs_count(), 1); // Only one complete pair

// Pairs iterator handles unpaired keys
let pairs: Vec<_> = u8pool.pairs().collect();
assert_eq!(pairs[0], (b"key1", Some(b"value1")));
assert_eq!(pairs[1], (b"key2", None));  // None for missing value
```

### Smart Replacement Logic
The `add_key()` and `add_value()` methods implement smart replacement:

```rust
// add_key() behavior:
if u8pool.is_empty() || !u8pool.has_unpaired_key() {
    // Add normally (last element is value or buffer empty)
    u8pool.push(data)
} else {
    // Replace last element (last element is key)
    u8pool.replace_last(data)
}

// add_value() behavior:
if u8pool.is_empty() || u8pool.has_unpaired_key() {
    // Add normally (last element is key or buffer empty)
    u8pool.push(data)  
} else {
    // Replace last element (last element is value)
    u8pool.replace_last(data)
}
```

## Design Characteristics

### Memory Layout
- **Metadata overhead**: 16 bytes per slice
- **No heap allocations**: All data in client buffer
- **Memory efficiency**: Sequential data layout

### Performance Guidelines
1. **Buffer sizing**: Overestimate to avoid overflow errors
2. **Max slices**: Set based on expected element count
3. **Access patterns**: Sequential access is most cache-friendly
4. **Memory usage**: Monitor by tracking element count and sizes

## Common Use Cases

### 1. Protocol Parsing
```rust
// Parse HTTP-like headers + body
u8pool.add_key(b"Content-Type")?;
u8pool.add_value(b"application/json")?;
u8pool.add_key(b"Content-Length")?;
u8pool.add_value(b"256")?;
u8pool.push(b"POST")?;
u8pool.push(b"/api/endpoint")?;
```

### 2. Configuration Management
```rust
// Key-value config with additional metadata
u8pool.add_key(b"database_url")?;
u8pool.add_value(b"postgresql://...")?;
u8pool.add_key(b"max_connections")?;
u8pool.add_value(b"100")?;
u8pool.push(b"production")?;  // Environment tag
```

### 3. Expression Parsing
```rust
// Stack-based expression evaluation
u8pool.push(b"3")?;
u8pool.push(b"4")?;
u8pool.push(b"+")?;
u8pool.push(b"2")?;
u8pool.push(b"*")?;
// Process with stack operations
```

### 4. Log/Event Processing
```rust
// Vector of events with metadata
u8pool.push(b"2023-01-01T10:00:00")?;
u8pool.push(b"INFO")?;
u8pool.push(b"Server started")?;
u8pool.push(b"2023-01-01T10:01:00")?;
u8pool.push(b"ERROR")?;
u8pool.push(b"Connection failed")?;
```

## Best Practices

### 1. Error Handling
- **Use `?` operator** for error propagation - errors include descriptive messages automatically
- **Match specific error types** when recovery is possible - access both message and structured data
- **Use safe variants** (`try_*`) when bounds are uncertain to avoid panics
- **Log with context** - utilize both `Display` trait for messages and structured fields for details
- **Leverage `thiserror`** - errors work seamlessly with standard error handling patterns

### 2. Buffer Management
- Calculate buffer size conservatively: `(max_slices * 16) + (expected_data * 1.5)`
- Monitor usage by tracking element count and sizes to prevent overflow
- Consider buffer reuse in loops to avoid allocations

### 3. Interface Selection
- Use **vector** interface for indexed access and general data storage
- Use **stack** interface for LIFO processing and temporary state
- Use **dictionary** interface for key-value data and configuration

### 4. Performance Optimization
- Access elements sequentially when possible for cache efficiency
- Calculate data usage by tracking element sizes manually when needed
- Prefer larger buffers over frequent buffer changes

### 5. Memory Safety
- Always check error conditions, especially `BufferOverflow` and `SliceLimitExceeded`
- Use safe variants when index bounds are uncertain
- Clear buffer when reusing to avoid stale data confusion

## Integration Examples

### Example 1: JSON-like Parser
```rust
fn parse_json_like(data: &str, u8pool: &mut U8Pool) -> Result<(), U8PoolError> {
    // Simple key:value,key:value parser
    for pair in data.split(',') {
        let parts: Vec<&str> = pair.split(':').collect();
        if parts.len() == 2 {
            u8pool.add_key(parts[0].trim().as_bytes())?;
            u8pool.add_value(parts[1].trim().as_bytes())?;
        }
    }
    Ok(())
}

let mut buffer = [0u8; 1000];
let mut u8pool = U8Pool::new(&mut buffer, 20)?;
parse_json_like("name:alice,age:30,city:NYC", &mut u8pool)?;

for (key, value) in u8pool.pairs() {
    println!("{:?} = {:?}", 
             std::str::from_utf8(key).unwrap(),
             std::str::from_utf8(value.unwrap()).unwrap());
}
```

### Example 2: Command Line Argument Processing
```rust
fn process_args(args: &[&str], u8pool: &mut U8Pool) -> Result<(), U8PoolError> {
    let mut i = 0;
    while i < args.len() {
        if args[i].starts_with("--") {
            // Long option
            u8pool.add_key(args[i][2..].as_bytes())?;
            if i + 1 < args.len() && !args[i + 1].starts_with("-") {
                u8pool.add_value(args[i + 1].as_bytes())?;
                i += 2;
            } else {
                i += 1;
            }
        } else {
            // Positional argument
            u8pool.push(args[i].as_bytes())?;
            i += 1;
        }
    }
    Ok(())
}
```

### Example 3: State Machine Processing
```rust
fn process_state_machine(events: &[&str], u8pool: &mut U8Pool) -> Result<(), U8PoolError> {
    u8pool.push(b"initial")?; // Initial state
    
    for event in events {
        let current_state = u8pool.top();
        
        // State transition logic
        match (current_state, event.as_bytes()) {
            (b"initial", b"start") => {
                u8pool.pop(); // Returns Option, safe to ignore
                u8pool.push(b"running")?;
            },
            (b"running", b"pause") => {
                u8pool.push(b"paused")?; // Keep running state below
            },
            (b"paused", b"resume") => {
                u8pool.pop(); // Returns Option, safe to ignore
            },
            (b"running", b"stop") => {
                u8pool.pop(); // Returns Option, safe to ignore
                u8pool.push(b"stopped")?;
            },
            _ => {}, // Invalid transition
        }
    }
    
    Ok(())
}
```

This documentation provides comprehensive guidance for LLMs to understand and effectively use U8Pool in various scenarios.