U8Pool: Uses preallocated memory to store byte slices. The interface is stack-based, with `Vec` and `Map` iterators. The code is `no_std`, with `thiserror` as the only dependency.

## API Summary

**Construction:**

- `U8Pool::new(buffer: &mut [u8], max_slices: usize)` - Creates a pool with custom slice limit
- `U8Pool::with_default_max_slices(buffer: &mut [u8])` - Creates a pool with default limit (32 slices)

**Stack Operations:**

- `push(&mut self, data: &[u8])` - Adds a slice to the pool
- `pop(&mut self) -> Option<&[u8]>` - Removes and returns the last slice
- `get(&self, index: usize) -> Option<&[u8]>` - Accesses a slice by index
- `clear(&mut self)` - Removes all slices

**Information:**

- `len(&self) -> usize` - Returns the number of slices stored
- `is_empty(&self) -> bool` - Checks if the pool is empty

**Iteration:**

- `iter(&self)` - Returns a forward iterator over slices
- `iter_rev(&self)` - Returns a reverse iterator over slices
- `pairs(&self)` - Returns an iterator over key-value pairs (even/odd slices). If there is an odd number of slices, the last slice is ignored

**Error Handling:**

All operations that can fail return `Result<T, U8PoolError>` with these error types:

- `InvalidInitialization` - Invalid buffer or `max_slices` parameter
- `SliceLimitExceeded` - Too many slices have been added
- `BufferOverflow` - Insufficient space for data
- `ValueTooLarge` - Slice position or length exceeds `u16::MAX`
